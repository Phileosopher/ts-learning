# Right to Repair

[Massachusetts voters pass right-to-repair expansion opening up car data | Hacker News](https://news.ycombinator.com/item?id=24987691)
  https://www.buyforlifeproducts.com/
    https://news.ycombinator.com/item?id=24707407
  EU brings in 'right to repair' rules for appliances
    https://www.bbc.com/news/business-49884827
    Comments URL: https://news.ycombinator.com/item?id=21121395
  https://spectrum.ieee.org/green-tech/conservation/why-we-must-fight-for-the-right-to-repair-our-electronics
  https://www.theguardian.com/world/2018/mar/15/can-we-fix-it-the-repair-cafes-waging-war-on-throwaway-culture
  https://www.npr.org/sections/thetwo-way/2018/04/11/601582169/warranty-void-if-removed-as-it-turns-out-feds-say-those-warnings-are-illegal
  https://fixitclub.com/
  Support for right-to-repair laws slowly grows
    Thursday, June 20, 2019
    5:56 PM
    Article URL: https://arstechnica.com/gadgets/2019/06/hackers-farmers-and-doctors-unite-support-for-right-to-repair-laws-slowly-grows/
    Comments URL: https://news.ycombinator.com/item?id=20232318
    Points: 600
    # Comments: 201
    June 20, 2019 at 05:49AM
  Nebraska farmers support right to repair
    Nebraska farmers vote overwhelmingly for Right to Repair	16.12.19 12:33
    Author: howard941 | Comments
    Article URL: https://uspirg.org/blogs/blog/usp/nebraska-farmers-vote-overwhelmingly-right-repair
    Comments URL: https://news.ycombinator.com/item?id=21805633
[Europe Is Guaranteeing Citizens the Right to Repair | Hacker News](https://news.ycombinator.com/item?id=25728453)

# Gleaned Axioms

[XY problem - Wikipedia](https://en.wikipedia.org/wiki/XY_problem)
[All the best engineering advice I stole from non-technical people | Hacker News](https://news.ycombinator.com/item?id=20610839)
[Always Bet on Text (2014) | Hacker News](https://news.ycombinator.com/item?id=26164001)



From the Cathedral and the Bazaar
  https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar
  [add to GR read?]
  Raymond points to 19 "lessons" learned from various software development efforts, each describing attributes associated with good practice in open source software development:[3]
    Every good work of software starts by scratching a developer's personal itch.
    Good programmers know what to write. Great ones know what to rewrite (and reuse).
    Plan to throw one [version] away; you will, anyhow (copied from Frederick Brooks's The Mythical Man-Month).
    If you have the right attitude, interesting problems will find you.
    When you lose interest in a program, your last duty to it is to hand it off to a competent successor.
    Treating your users as co-developers is your least-hassle route to rapid code improvement and effective debugging.
    Release early. Release often. And listen to your customers.
    Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone.
    Smart data structures and dumb code works a lot better than the other way around.
    If you treat your beta-testers as if they're your most valuable resource, they will respond by becoming your most valuable resource.
    The next best thing to having good ideas is recognizing good ideas from your users. Sometimes the latter is better.
    Often, the most striking and innovative solutions come from realizing that your concept of the problem was wrong.
    Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away. (Attributed to Antoine de Saint-Exupéry)
    Any tool should be useful in the expected way, but a truly great tool lends itself to uses you never expected.
    When writing gateway software of any kind, take pains to disturb the data stream as little as possible—and never throw away information unless the recipient forces you to!
    When your language is nowhere near Turing-complete, syntactic sugar can be your friend.
    A security system is only as secure as its secret. Beware of pseudo-secrets.
    To solve an interesting problem, start by finding a problem that is interesting to you.
    Provided the development coordinator has a communications medium at least as good as the Internet, and knows how to lead without coercion, many heads are inevitably better than one.
from Computer Organization and Design
  Design Principles
    a. Simplicity favors regularity
    b. Smaller is faster
  Great Ideas in Computer Architecture
    1 Design for Moore's Law
    Computer architects must adapt to the RAPID exponential growth and change of their systems
    2 Use abstraction to simplify design
    To avoid the design time lengthening from Moore's Law, engineers and architects have to use productivity enhancements
    Abstractions offer a simple model at higher levels to allow people to work with what makes the difference in results
    3 Make the common case fast
    The common case creates WAY more results by optimizing than the rare case
    Ironically, the common case is also often more simple and, therefore, easier to optimize
    4 Performance via parallelism
    Performing operations in parallel make computing faster because they streamline the project flow (Gantt Chart on nanosecond basis)
    5 Performance via pipelining
    Pipelining is a specific type of parallelism built around the idea of a "bucket brigade" instead of individuals each carrying a bucket
    6 Performance via prediction
    It's better to guess and start working than waiting to know for sure, then editing the results later when you do know
    6 Hierarchy of memories
    Programmers want fast, cheap, and large memory
    Speed often shapes performance
    Capacity limits the size of solvable problems
    The majority of computer cost is the cost of memory (at least today)
    Caches give the illusion of extra memory for working
    The closer to the top, the more expensive and speedy the memory
    7 Dependability via redundancy
    Computer need to be reliable, which is why they need redundant systems that can restore information
Two Generals Problem
  https://www.microsoft.com/en-us/research/publication/byzantine-generals-problem/
  https://en.wikipedia.org/wiki/Two_Generals%27_Problem
  Two Generals’ Problem – Two entities are trying to come to a consensus and send messengers to communicate, but have no ability to know if their message got through. More broadly known as the Byzantine Generals Problem. Popular in computer science.
