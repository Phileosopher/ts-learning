Pointers are so difficult that more recent languages, C# for example, relegate them to "unsafe" code or remove from the language altogether. However pointers are an integral part of C and mastering them is essential hence this book. 

Pointers were included in C as a way to abstract the notion of "address" and ideas such as indirection. If you have learned to program starting with the low level hardware, preferably by learning assembler, then the idea of an address will be natural and you will be able to understand pointers very easily. This doesn't mean that there isn't scope for making mistakes as the notation used in C and aspects of the semantics are confusing. 

Chapter 1 starts off with a general overview. This is a good idea but it is difficult to introduce pointers in a completely logical way and there are many forward references. The basic idea of a pointer is introduced and while the idea that a pointer is an address is used it isn't really made enough of. There are some nice touches that relate to avoiding errors and what you might call the "tricks of the trade" - again some of these aren't made enough of. For example something that most beginners find difficult is reading C pointer declarations and the excellent advice "read them backwards" is given. This rule actually works and saves hours but the advice is provided as a tiny sentence with one example. It is almost as if the little bits of common sense introduced in the book aren't valued as proper knowledge in some way. More of the informal "how I think about pointers" would have made the book a better one - these ideas should be relegated to boxouts. 

By the end of the first chapter you have encountered everything to do with basic pointers - declaring pointers, address of operator, dereferencing and point arithmetic. The explanations make an attempt to explain what is going on at the lower level and yet in my opinion they failed to motivate the ideas. For example, pointer arithmetic is as it is because it mimics array indexing and the two views of an array as an indexed data structure or as a buffer with pointer arithmetic are crucial to the development and understanding of why C pointers work in the ways that they do. In my opinion the book lacks the sort of statements of grand principle that makes the whole thing hang together. 

Chapter 2 is about dynamic memory management and the proper use of malloc and its associated functions. This goes from the very basics to the consideration of topics such as garbage collection but only briefly.

cpointers

Chapter 3 deals with the murky topic of pointers and functions. This doesn't dwell too much on the idea of using pointers to dispatch functions. It does go over the very basic ideas of using pointers to pass by reference and return results by reference. This is so basic to the language it makes you wonder how a C programmer could have survived this long without understanding it. When it comes to function pointers i.e. pointers to functions then while the ideas are well explained it would be better with some examples of where they are useful. The idea that you can usually avoid the use of function pointers using appropriate control structures isn't really explained. For example the idea that you can setup an array of functions as a function lookup table is presented but the alternative approach of simply using a case statement or nested if isn't pointed out. 

Chapter 4 returns to pointers and arrays and here we meet for the second time pointer arithmetic. The more advanced ideas of working with multidimensional arrays, jagged arrays and arrays of pointers are also introduced. Chapter 5 does the same thing for strings and Chapter 6 for structures. In Chapter 6 we learn about queues, stacks and trees as implemented by pointers. 

The last two chapters deal with security and a collection of topics that don't fit elsewhere. The chapter on security is basically a recap of the lessons of the earlier chapters about using pointers when they don't point to anything sensible. The final chapter deals with some strange things including accessing hardware at fixed addresses.  It also deals with using threads and pointers which is one way to make truly subtle errors. 

I enjoyed reading this book but it has a number of problems. The first, and perhaps the biggest, is that the topic isn't as difficult as the existence of a book might suggest. If you understand the basic idea of a typed pointer, there isn't much more to say. Yes, you can still make mistakes with pointers, even if you understand the concept, but they all come down to the same mistake - using a pointer that doesn't point at anything that is valid. There are complex and subtle ways that you can make this error but these tend to be very specific and difficult to explain in general ways. 

I suppose the real problem with the subject matter is that the principles of operation are few in number and could be presented in medium length article and after that it's a matter of a long learning process of how you can make a mess of it.

This book presents the principles by explaining how the same basic ideas are reused in different ways - pointers to functions, arrays, strings and so on. If you know the principles then this can be a fun way of making sure you know how they apply. By the time you reach the end of the book you will at least be confident that you have seen a lot of ways that pointers are used in C. 

Recommended with reservations. 

