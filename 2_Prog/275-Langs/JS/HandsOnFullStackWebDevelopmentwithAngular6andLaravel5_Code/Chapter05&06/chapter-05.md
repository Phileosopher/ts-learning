# Chapter 05 Creating a Restful API using Laravel Framework
---

In this chapter you will learn to build a Restful API using the core elements of Laravel Framework as: Controllers, Routes, Eloquent ORM and how to deal with error and logging.

1. Using Git and source control.
2. Structuring the Sample Application.
3. Eloquent ORM relationship.
4. Dealing with error and logging.
5. Token based Authentication.


# Using Git and source control.

Let's start this session using the application that we started to develop in the previous chapter.
However, we will make some adjustments before continuing. First we are going to add our code to the version control, in this way we will not lose the progress we made in the previous chapter.

1. Inside the **chapter-04** folder, create a new file called **.gitignore** and add the following code:

```
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'

# Ignore Storage folder due size.
storage-db
.DS_Store
```
The previous code just add the folder **storage-db** to untracked files.

2. Let's add the changes to source control, inside the Terminal window type the following command:

`git init`

And finally let's add our first commit.

3. inside the Terminal, type the following commands:

`git add .`
`git commit -m "first commit"`

Bravo! We have our code under Git source control.

## Refactoring the application files.

Now it is time to change some files to adjust to chapter-05.

1. Copy all the content of chapter-04 and paste o a new folder called: chapter-05;
2. Open **docker-compose.yml** file and replace the code, for the following lines:

```
version: "3.1"
services:

    mysql:
      image: mysql:5.7
      container_name: chapter-05-mysql
      working_dir: /application
      volumes:
        - .:/application
        - ./storage-db:/var/lib/mysql
      environment:
        - MYSQL_ROOT_PASSWORD=123456
        - MYSQL_DATABASE=chapter-05
        - MYSQL_USER=chapter-05
        - MYSQL_PASSWORD=123456
      ports:
        - "8083:3306"

    webserver:
      image: nginx:alpine
      container_name: chapter-05-webserver
      working_dir: /application
      volumes:
          - .:/application
          - ./phpdocker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf
      ports:
       - "8081:80"

    php-fpm:
      build: phpdocker/php-fpm
      container_name: chapter-05-php-fpm
      working_dir: /application
      volumes:
        - ./project:/application
        - ./phpdocker/php-fpm/php-ini-overrides.ini:/etc/php/7.2/fpm/conf.d/99-overrides.ini
```

Note that we changed our database name and user and also change the container names, to fit **chapter-05** title.

3. Edit **project/.env** file with the new database information as the following code:

```
DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=chapter-05
DB_USERNAME=chapter-05
DB_PASSWORD=123456
```
4. Now, delete the **storage-db** folder, don't worry, we will create a new one with **docker-compose** command later.

It's time to commit our new changes, but this time we will do in another way. This time we will use the Gitlens vscode plugin.

5. Open vs.code, on left side bar click on third icon: source control.
6. Add the following message inside the Message box at the top of left sidebar: Init chapter 05
7. Press **command + enter** on MacOSX or **ctrl + enter** on Windows and click yes.

Well done. Now we can start the chapter 05 with.

# Structuring the Sample Application

Now let's talk a bit about the application we will build from now until the end of the book.

As we can see we have already built a lot of things so far, but we still do not have a clear idea of ​​what we are doing about the project. And this is the best way to learn and practice web application development.

Many times when we are learning or doing something for the first time, we tend to pay close attention to the final project, and at this point there is an anxiety to finish what we started to do and we can not focus on the building process and details.

Here we already have 40% of our project ready. Then we can reveal more details about what we are doing. Remember, until now we have prepared a highly scalable development environment using Docker, installed some very important tools that will help us in our development and learn how to start a solid Laravel application.

The application will be called as: Custom Bike Garage, a kind of instagram / twitter for lovers of custom motorcycle culture. At the end of the development we will have a web application very similar to the following images.

- image: chapter-05-home.png
- image: chapter-05-biker-list.png

## The application summary

As we can see in the previous images, our application has;

* A home page, which we will call **home** page.
* A page of motorcycles, which we will call a **bike-list** page.
* A builders page, which we'll call a **builders-list** page.
* A **login** page.
* A **registration** page.

Users can view content partially, but to interact with the application they must register and log in. They can vote on favorite bike, search, and filter data.

So what we still need to create to complete the backend of the application is:

* Create models for: Builder, Item, Garage.
* Create migration files for: Builder, Item, Garage.
* Seeding database.
* Create controllers for: Bikes, Builder, Item, Garage.
* Apply the relationship between models.
* User authentication and login.

## Creating models and migrations files.

Let's starting creating the **builders** model and migration file, using the **-m** flag, as we did before early in the book we can create both files at the same time.

1. Open your Terminal window and type the following command:

`php artisan make:model Builder -m`

2. Still on your Terminal window and type the following command:

`php artisan make:model Item -m`

3. Still on your Terminal window and type the following command:

`php artisan make:model Garage -m`

The previous steps 1, 2, 3 will produce the folloiwng new files on our application:

`project/app/Builder.php`
`project/database/migrations/XXXX_XX_XX_XXXXXX_create_builders_table.php`

`project/app/Item.php`
`project/database/migrations/XXXX_XX_XX_XXXXXX_create_items_table.php`

`project/app/Garage.php`
`project/database/migrations/XXXX_XX_XX_XXXXXX_create_garages_table.php`

> Note the **XXXX_XX_XX_XXXXXX** befre the migration file name, is a timestamp when you create the file.

At this point we can see the previous files highlighted on vs.code left side panel, as the following image:

-image: leftsidepanel.png

4. Now as we did before, let's commit the new files created, click: source control icon on vs.code left panel.
5. Type the following text inside the message input field:

`Added Models and Migration files`

6. Press **command + enter** on MacOSX or **ctrl + enter** on Windows and click yes.

## Adding content to migration files.

Now let's create the content for the migration files.

1. Open **project/database/migrations/XXXX_XX_XX_XXXXXX_create_builders_table.php** and replace the content for the following code:

```
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateBuildersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('builders', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name');
            $table->text('description');
            $table->string('location');
            $table->integer('bike_id');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('builders');
    }
}
```

> Notice the **$table->integer('bike_id')** foreign key to Bike table, later in this chapter we go deep in models relationship, for now let's focus on migrations.

2. Open **project/database/migrations/XXXX_XX_XX_XXXXXX_create_items_table.php** and replace the content for the following code:

```
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateItemsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('items', function (Blueprint $table) {
            $table->increments('id');
            $table->string('type');
            $table->string('name');
            $table->text('company');
            $table->integer('bike_id');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('items');
    }
}
```

3. Open **project/database/migrations/XXXX_XX_XX_XXXXXX_create_garages_table.php** and replace the content for the following code:

```
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateGaragesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('garages', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name');
            $table->integer('customer_level');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('garages');
    }
}
```

Now we need another table, just to setup the relationship between Bikes and Garages. So we are using the Artisan command to create only a migration file. This table also know ad pivot table.

4. Open your Terminal window and type the following command:

`php artisan make:migration create_bike_garage_table`

5. Open **project/database/migrations/XXXX_XX_XX_XXXXXX_create_bike_garage_table.php** and replace the content for the following code:

```
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateBikeGarageTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('bike_garage', function (Blueprint $table) {
            $table->increments('id');
            $table->integer('bike_id');
            $table->integer('garage_id');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('bike_garage');
    }
}
```

Well, its time to understand a bit more what we did in this session, let's go to the next session and understand how Eloquent works.

# Eloquent ORM relationship.

Eloquent is the ORM (Object Relational Mapping) that is behind the database queries of Laravel. It's an abstraction of **Active Record** implementation.

As we saw previously each application **Model** has a respective **Table** in our database. With this, we can querie, insert, delete and update records.

The Eloquent ORM use the "snake case", plural name of the class will be used as the table name unless another name is explicitly specified, for example our **Bike Model Class** has it's table **bikes**:

```
// project/app/Bike.php

class Bike extends Model
{
    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'make',
        'model',
        'year',
        'mods',
        'picture'
    ];
}
```

```
// project/database/migrations/XXXX_XX_XX_XXXXXX_create_bikes_table.php

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateBikesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('bikes', function (Blueprint $table) {
            $table->increments('id');
            $table->string('make');
            $table->string('model');
            $table->string('year');
            $table->text('mods');
            $table->string('picture');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('bikes');
    }
}
```

Later we will see how to use a custom table name. For now, let's understand Model relationship.

The Eloquent ORM support the following relationship between models:

* One to one
* One to many
* One to many - inverse = belongs_to
* Many to many
* Has Many Through
* Polymorphic Relations
* Many To Many Polymorphic Relations

We will see the first four relationships in detail, however we can't cover all relationships with code and example in this book.

> You can read more about relationship at the following documentation: https://laravel.com/docs/5.6/eloquent-relationships


## One-to-one relationship
Let's setup the one-to-one relationship between Builder and Bike. This means that a Builder will have just one Bike.

1. Open **project/app/Builder.php** and replace the content for the following code:

```
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

 /**
 * @SWG\Definition(
 *     definition="Builder",
 *     required={"name", "description", "location"},
 *     @SWG\Property(
 *          property="name",
 *          type="string",
 *          description="Builder name",
 *          example="Jesse James"
 *    ),
 *     @SWG\Property(
 *          property="description",
 *          type="string",
 *          description="Famous Motorcycle builder from Texas",
 *          example="Austin Speed Shop"
 *    ),
 *     @SWG\Property(
 *          property="location",
 *          type="string",
 *          description="Texas/USA",
 *          example="Austin, Texas"
 *    ),
 * )
 */


class Builder extends Model
{
    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'builders';

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'description',
        'location',
        'bike_id'
    ];

    /**
     * Relationship.
     *
     * @var string
     */

    public function bike() {
        return $this->belongsTo('App\Bike');
    }
}

```

Note that we added the Swagger documentation definition as we did on previous chapter and the **bike()** function create a one-to-one (reverse) relationship. You can use any name on the relationship function, but we strong recommend to use the same model name, in our case **Bike Model Class**.


2. Now let's add the respective relationship to Bike model, open **project/app/Bike.php** and add the following code right after the **protected fillable** function:

```
    /**
     * Relationship.
     *
     * @var string
     */

    public function builders() {
        return $this->hasOne('App\Builder');
    }
```

3. Open **project/app/Item.php** and replace the content for the following code:

```
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

 /**
 * @SWG\Definition(
 *     definition="Item",
 *     required={"type", "name", "company"},
 *     @SWG\Property(
 *          property="type",
 *          type="string",
 *          description="Item Type",
 *          example="Exhaust"
 *    ),
 *     @SWG\Property(
 *          property="name",
 *          type="string",
 *          description="Item name",
 *          example="2 into 1 Exhaust"
 *    ),
 *     @SWG\Property(
 *          property="company",
 *          type="string",
 *          description="Produced by: some company",
 *          example="Vance and Hines"
 *    )
 * )
 */

class Item extends Model
{
    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'items';

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'type',
        'name',
        'company',
        'bike_id'
    ];

    /**
     * Relationship.
     *
     * @var string
     */

    public function bike() {
        return $this->belongsTo('App\Bike');
    }
}


```

## One-to-many relationship

The one-to-many will be applied to Bike to Items, this means that one Bike will have many custom Items. 
Still o **project/app/Bike.app** file, let's add the **one-to-many** relationship between **Item** and **Bike** model.

4. Add the following code right after the **builders()** function:

```
    public function items() {
        return $this->hasMany('App\Item');
    }
```


## Many-to-many relationship

For many-to-many relationship we will have many Bikes in many Garages, using the Pivot table.

On many-to-many relationship we need to respect some naming rules, Name of the pivot table should consist of singular names of both tables, separated by undescore symbol and these names should be arranged in alphabetical order.

Pivot table fields: by default, there should be only two fields – foreign key to each of the tables, in our case bike_id and garage_id.

Still o **project/app/Bike.app** file, let's add the **many-to-many** relationship between **Bike** and **Garage** model.

5. Add the following code right after the **items()** function:

```
    public function garages() {
        return $this->belongsToMany('App\Garage', 'bike_garage', 'bike_id', 'garage_id');
    }
```

Notice the previous code we are creating the relationship of **Bike** and **Garage** in a third table, called as pivot table which will hold the information of the relationship.

At the end of step 4 we will have the following relationship on Bike model:

```
/**
     * Relationship.
     *
     * @var string
     */

    public function builders() {
        return $this->hasOne('App\Builder');
    }

    public function items() {
        return $this->hasMany('App\Item');
    }

    public function garages() {
        return $this->belongsToMany('App\Garage', 'bike_garage', 'bike_id', 'garage_id');
    }
```

6. Now let's add the relationship on **project/app/Garage.app** model, replace the content for the following code:

```
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

 /**
 * @SWG\Definition(
 *     definition="Garage",
 *     required={"name", "custumer_level"},
 *     @SWG\Property(
 *          property="name",
 *          type="string",
 *          description="Jhonny Garage",
 *          example="Exhaust"
 *    ),
 *     @SWG\Property(
 *          property="customer_level",
 *          type="integer",
 *          description= 9,
 *          example="10"
 *    )
 * )
 */

class Garage extends Model
{
    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'garages';

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'costumer_level'
    ];

    /**
     * Relationship.
     *
     * @var string
     */

    public function bikes() {
        return $this->belongsToMany('App\Bike', 'bike_garage', 'bike_id', 'garage_id');
    }
}
```

Note that we are using **belongsToMany()** and not **hasMany()**. hasMany is used for one-to-many relationships.

Now that we have our migrations files and application models done, we can seed our database. We will use Eloquent for inserting into our database for our seeds. But before to go further, let's migrate our tables to our database.

7. Inside your Terminal window, type the following command:

`php artisan migrate`

Well done! We have successfully migrate all our tables.

## Seeding our Database.

Remember on last chapter we already created the Bike seed, so now we just need to create another three seeds, Builders, Items and Garage.

1. On your Terminal window type the following command:

`php artisan make:seeder BuildersTableSeeder`

2. Add the following code to: **app/database/seeds/BuildersTableSeeder.php** public function run():

```
        DB::table('builders')->delete();
        $json = File::get("database/data-sample/builders.json");
        $data = json_decode($json);
        foreach ($data as $obj) {
            Bike::create(array(
                'id' => $obj->id,
                'name' => $obj->name,
                'description' => $obj->description,
                'location' => $obj->location,
                'bike_id' => $obj->bike_id
            ));
        }
```


3. Still on your Terminal window type the following command:

`php artisan make:seeder ItemsTableSeeder`

4. Add the following code to: **app/database/seeds/ItemsTableSeeder.php**:

```
        DB::table('items')->delete();
        $json = File::get("database/data-sample/items.json");
        $data = json_decode($json);
        foreach ($data as $obj) {
            Bike::create(array(
                'id' => $obj->id,
                'type' => $obj->type,
                'name' => $obj->name,
                'company' => $obj->company,
                'bike_id' => $obj->bike_id
            ));
        }
```

5. On your Terminal window type the following command:

`php artisan make:seeder GaragesTableSeeder`

6. Add the following code to: **app/database/seeds/GaragesTableSeeder.php** public function run():

```
        DB::table('garages')->delete();
        $json = File::get("database/data-sample/garages.json");
        $data = json_decode($json);
        foreach ($data as $obj) {
            Bike::create(array(
                'id' => $obj->id,
                'name' => $obj->name,
                'customer_level' => $obj->customer_level
            ));
        }
```

Note that we are using the same function as we did on previous chapter, to load sample data. So it's time to create the JSON files.

7. Inside **project/database/data-sample/**, create a new file called: **builders.json** and add the following code:

```
[{
	"id": 1,
	"name": "DIAMOND ATELIER",
	"description": "Diamond Atelier was founded by two fellow riders who grew tired of the same played-out custom bike look and feel they and their friends had grown accustomed to witnessing.",
	"location": "Munich, Germany",
	"bike_id": 3
},{
	"id": 2,
	"name": "DEUS EX MACHINAs",
	"description": "Established in Australia back in 2006. And what started on the East Coast of Australia has spread across the world, building an empire of cafe racers.",
	"location": "Sydney, Australia",
	"bike_id": 1
},{
	"id": 3,
	"name": "ROUGH CRAFTS",
	"description": "A true testament to how far the custom bike world has come since the introduction of motorcycles in the early 20th century, Taiwan-based Rough Crafts is a design powerhouse.",
	"location": "Taiwan",
	"bike_id": 2
}]
```

8. Inside **project/database/data-sample/**, create a new file called: **items.json** and add the following code:

```
[{
	"id": 1,
	"type": "Handlebars",
	"name": "Apes Hanger 16 ",
	"company": "TC Bros",
	"bike_id": 2
},{
	"id": 2,
	"type": "Seat",
	"name": "Challenger",
	"company": "Biltwell Inc",
	"bike_id": 3
},{
	"id": 3,
	"type": "Grips",
	"name": "Kung Fu",
	"company": "Biltwell Inc",
	"bike_id": 3
}]
```

9. Inside **project/database/data-sample/**, create a new file called: **garages.json** and add the following code:

```
[{
	"id": 1,
	"name": "Martin Smith",
	"customer_level": 8
}, {
	"id": 2,
	"name": "Collin James",
	"customer_level": 9
}]
```

Now we need to create the last seed to make the relationship between Bikes and Garages.

10. Still on Terminal window, type the following command:

`php artisan make:seeder BikeGarageTableSeeder``


11. Add the following code to: **app/database/seeds/BikeGarageTableSeeder.php** public function run():

```
        DB::table('bike_garage')->insert([
            'bike_id' => 1,
            'garage_id' => 2
        ]);
        DB::table('bike_garage')->insert([
            'bike_id' => 3,
            'garage_id' => 2
        ]);
```

Notice the previous code, we just insert the records manually using the Eloquent **insert** method.

## Quering Database using Tinker.

Tinker is a command line application that allows you to interact with your Laravel application, including the Eloquent ORM, jobs, events, and more. To get access to Tinker console, run the tinker Artisan command that we previously used to check database connection on chapter 01.

1. Open your Terminal window and type the following command:

`php artisan tinker`

Since we have not created any controller or routes for our application, we still can not access our records using the browser and our API endpoints, however using Tinker it is possible to interact with our database and check if everything went well with our migration files and database seed.

Let's go to the **builders** table and make sure everything is set up correctly.

2. Still on your Terminal and inside tinker console, type the following command:

`$builders = Builder::has('bike')->get();`

The output on your Terminal will be very similar to the following image:

- image: tinker-querie.png

Note that the previous image return all builders, because all builders has a bike. So let's make another request.

3. Still on your Terminal and inside tinker console, type the following command:

`$builders = DB::table('builders')->get();`

Here we have the same result as the previous one, but now using the **DB::table()** function instead the **Builder** model querie as step 2.

4. Still on your Terminal and inside tinker console, type the following command:

`$builder = Builder::where('bike_id', '=', 2)->get();`

we will have the following image as querie result:

-image: tinker-querie-2.parking

5. So imagine that we want to querie all customized bikes. Still on your Terminal and inside tinker console, type the following command:

`$customBike = Bike::with('items')->get();`

Note that, this time we get all the 5 bikes in our database, but we get all the custom items too, as we can see on the following image:

-image: custom bike 2

-image: custom bike 3

We can see all the relationship from Bikes with Items in **items: Illuminate\Database\Eloquent\Collection {all:[]}**

```
App\Bike {#813
         id: 3,
         make: "Harley Davidson",
         model: "Dyna Switchback",
         year: "2009",
         mods: "Nobis vero sint non eius. Laboriosam sed odit hic quia doloribus. Numquam laboriosam numquam quas quis.",
         picture: "https://placeimg.com/640/480/nature",
         created_at: "2018-04-15 22:00:44",
         updated_at: "2018-04-15 22:00:44",
         items: Illuminate\Database\Eloquent\Collection {#787
           all: [
             App\Item {#826
               id: 2,
               type: "Seat",
               name: "Challenger",
               company: "Biltwell Inc",
               bike_id: 3,
               created_at: "2018-04-15 22:00:45",
               updated_at: "2018-04-15 22:00:45",
             },
             App\Item {#827
               id: 3,
               type: "Grips",
               name: "Kung Fu",
               company: "Biltwell Inc",
               bike_id: 3,
               created_at: "2018-04-15 22:00:45",
               updated_at: "2018-04-15 22:00:45",
             },
           ],
         },
       },
```



php artisan make:resource Builders

php artisan make:controller API/ItemsController --api


`php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider"`
saida: 
Copied File [/vendor/tymon/jwt-auth/config/config.php] To [/config/jwt.php]
Publishing complete.

`php artisan jwt:secret`

saida: jwt-auth secret [KaAY0fYqrTb4fVJSk4V6eJuilTvG0MZI] set successfully.